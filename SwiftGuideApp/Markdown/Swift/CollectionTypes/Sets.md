# Множества
Множество хранит различные значения одного типа в виде коллекции в неупорядоченной форме. Вы можете использовать множества как альтернативы массиву, когда порядок для вас значения не имеет или когда вам нужно быть уверенным в том, что значения внутри коллекции не повторяются.

    Тип Swift Set связан с классом Foundation NSSet.

## Хеш значения для типа Set
Тип должен быть хешируемым для того, чтобы мог храниться в множестве, таким образом тип должен предоставлять возможность для вычисления собственного значения хеша. Тип значения хеша Int должен быть для всех объектов одинаковым, чтобы можно было провести сравнение что если a == b, то и a.hashValue == b.hashValue.

Все базовые типы Swift (Int, String, Double, Bool) являются хешируемыми типами по умолчанию и могут быть использованы в качестве типов значений множества или в качестве типов ключей словаря. Значения членов перечисления без каких-либо связанных значений так же являются хешируемыми по умолчанию.

    Вы можете использовать ваш собственный тип в качестве типа значения множества или типа ключа словаря, подписав его под протокол Hashable из стандартной библиотеки Swift. Типы, которые подписаны под протокол Hashable должны обеспечивать gettable свойство hashValue. Значение, которое возвращает hashValue не обязательно должно иметь одно и то же значение при выполнении одной и той же программы или разных программ. 
    Так как протокол Hashable подписан под протокол Equatable, то подписанные под него типы так же должны предоставлять реализацию оператора равенства ==. Протокол Equatable требует любую реализацию оператора равенства для реализации возможности сравнения. Таким образом, реализация оператора == должна удовлетворять следующим трем условиям, для всех трех значений a, b, c.
    1. a == a (Рефлексивность)
    2. a == b, значит b == a (Симметрия)
    3. b == a && b == c, значит a == c (Транзитивность)

## Синтаксис типа множества
Тип множества Swift записывается как Set<Element>, Element является типом, который хранится в множестве. В отличии от массивов множества не имеют сокращенной формы записи.

## Создание и инициализация пустого множества
Вы можете создать пустое множество конкретного типа, используя синтаксис инициализатора:

```swift
var letters = Set<Character>()
print("letters имеет тип Set<Character> с \(letters.count) элементами.")
// Выведет "letters имеет тип Set<Character> с 0 элементов."
```

    Тип переменной letters выведен из типа инициализатора как Set<Character>.

Альтернативно, если контекст предоставляет информацию о типе, например как аргумент функции или просто явное указание типа переменной или константы, то вы можете создать пустое множество при помощи пустого литерала массива:

```swift
letters.insert("a")
// letters теперь содержит 1 элемент типа Character
letters = []
// letters теперь является пустым множеством, но все еще имеет тип Set<Character>
```

## Создание множества при помощи литерала массива
Вы так же можете инициализировать множество при помощи литерала массива, чтобы использовать его в качестве сокращенной записи нескольких элементов в качестве коллекции множества.

Пример ниже создает множество favoriteGenres для хранения String.

```swift
var favoriteGenres: Set<String> = ["Rock", "Classical", "Hip hop"]
// favoriteGenres был инициализирован при помощи трех начальных элементов
```

Переменная favoriteGenres объявлена как множество значений типа String, который записывается как Set<String>. Так как это множество имеет определенный тип String, то этому множеству позволено хранить только значения типа String. Поэтому здесь мы инициализируем favoriteGenres тремя значениями типа String, записанными в виде литерала массива.

    Множество favoriteGenres объявлен как переменная (ключевое слово var), но не константа (ключевое слово let), так как мы добавляем и удаляем элементы в примере ниже.
    
Так как тип множества не может быть выведен только из литерала, то его тип должен быть указан явно. Однако из-за вывода типа в Swift вы не должны писать тип множества, если вы инициализируете его при помощи литерала массива, который содержит элементы одного типа. Вместо этого инициализация favoriteGenres может быть записана и в более короткой форме:

```swift
var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"]
```

Так как все элементы литерала массива одного типа, то Swift может вывести, что Set<String> является корректным типом для переменной favoriteGenres.

## Доступ и изменение множества
Получить доступ и модифицировать множества можно через свойства и методы.

Для того, чтобы выяснить количество элементов в множестве вам нужно использовать свойство count:

```swift
print("У меня есть \(favoriteGenres.count) любимых музыкальных жанра.")
// Выведет "У меня есть 3 любимых музыкальных жанра."
```

Используйте булево свойство isEmpty в качестве сокращенной проверки наличия элементов во множестве или другими словами равно ли свойство count 0:

```swift
if favoriteGenres.isEmpty {
    print("Мне все равно какая музыка играет. Я не придирчив.")
} else {
    print("У меня есть свои музыкальные предпочтения.")
}
// Выведет "У меня есть свои музыкальные предпочтения."
```

Вы можете добавить новый элемент во множество, используя метод insert(_:):

```swift
favoriteGenres.insert("Jazz")
// теперь в favoriteGenres находится 4 элемента
```

Вы так же можете удалить элемент из множества, используя метод remove(_:), который удаляет элемент, который является членом множества и возвращает удаленное значение или nil, если удаляемого элемента нет. Так же все объекты множества могут быть удалены единовременно при помощи метода removeAll().

```swift
if let removedGenre = favoriteGenres.remove("Rock") {
    print("\(removedGenre)? С меня хватит.")
} else {
    print("Меня это не сильно заботит.")
}
// Выведет "Rock? С меня хватит."
```

Можно проверить наличие определенного элемента во множестве, используя метод contains(_:):

```swift
if favoriteGenres.contains("Funk") {
    print("О! Да я встал с правильной ноги!")
} else {
    print("Слишком много Funk'а тут.")
}
// Выведет "Слишком много Funk'а тут."
```

## Итерация по множеству
Вы можете совершать итерации по множеству при помощи цикла for-in.

```swift
for genre in favoriteGenres {
    print("\(genre)")
}
// Classical
// Jazz
// Hip hop
```

Множества в Swift не имеют определенного порядка. Для того, чтобы провести итерацию по множеству в определенном порядке, вам нужно использовать метод sorted(), который возвращает вам элементы коллекции в виде отсортированного массива, используя оператор <.

```swift
for genre in favoriteGenres.sorted() {
    print("\(genre)")
}
// Classical
// Hip hop
// Jazz
```
