# Массивы
Массивы хранят много значений одинакового типа в упорядоченном списке. Одно и то же значение в массиве может появиться несколько раз, в разных позициях.

    Массив в Swift связан с классом Foundation  NSArray.

## Сокращённый синтаксис массивов
Полная форма записи массива в Swift пишется Array<Element>, где Element это тип значения, который может хранить массив.

Вы можете также написать массив в сокращенной форме как [Element].

Хотя две формы функционально идентичны, краткая форма является предпочтительной.

## Создание пустого массива
Вы можете создать пустой массив определенного типа с помощью синтаксиса инициализатора:

```swift
var someInts = [Int]()
print("someInts is of type [Int] with \(someInts.count) items.")
// Выведет "someInts is of type [Int] with 0 items."
```

Обратите внимание, что тип переменной someInts выводится как [Int] от типа инициализатора.

В качестве альтернативы, если контекст уже содержит информацию о типе, например, аргумент функции или уже типизированную переменную или константу, вы можете создать пустой массив с помощью пустого литерала массива, который записывается в виде [] (пустой пары квадратных скобок):

```swift
someInts.append(3)
// массив someInts теперь содержит одно значение типа Int
someInts = []
// массив someInts теперь пуст, но все равно имеет тип [Int]
```

## Создание массива с дефолтным значением
Тип массива в Swift также обеспечивает инициализатор для создания массива определенного размера со всеми его значениями, установленными на одно и тоже дефолтное значение. Вы передаете этому инициализатору дефолтное значение соответствующего типа (называемое repeating): и сколько раз это значение повторяется в новом массиве (так называемый count):

```swift
var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles имеет тип [Double] и равен [0.0, 0.0, 0.0]
```

## Создание массива, путем объединения двух массивов
Вы можете создать новый массив, объединив два существующих массива с совместимыми типами с оператором сложения (+). Новый тип массива выводится из типа двух массивов, которые вы объединяете вместе:

```swift
var anotherThreeDoubles = Array(repeating: 2.5, count: 3)
// anotherThreeDoubles имеет тип [Double] и равен [2.5, 2.5, 2.5]

var sixDoubles = threeDoubles + anotherThreeDoubles
// тип sixDoubles выведен как [Double] и равен [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
```

## Создание массива через литералы массива

Вы можете инициализировать массив с помощью литерала массива, который является быстрым способом писать одно или несколько значений как набор значений массива.

Литерал массива пишется в виде списка значений, разделенных запятыми и окруженными парами скобок:

    [значение 1, значение 2, значение 3]

В приведенном ниже примере создается массив под названием shoppingList для хранения String значений:

```swift
var shoppingList: [String] = ["Eggs", "Milk"]
// shoppingList был инициализирован с двумя элементами
```

Переменная shoppingList объявлена как "массив из String значений", который записывается как [String]. Поскольку для этого массива указан тип значения String, ему разрешено хранить только String значения. Здесь, массив shoppingList инициализирован двумя String значениями ("Eggs" и "Milk"), написанными внутри литерала массива.


    Массив shoppingList объявлен как переменная ( с помощью var ), а не константа ( с помощью let ), поскольку много элементов добавляются в список покупок в примерах ниже.
    
В данном случае литерал массива содержит два String значения и больше ничего. Это подходит типу, который мы присвоили при объявлении переменной shoppingList ( массив который может хранить только String значения), и поэтому присвоение литерала массива разрешено как способ инициализации shoppingList двумя начальными элементами.

Благодаря выводу типов Swift, вы можете не писать тип для массива, который вы инициализируйте с помощью литерала массива, хранящего значения того же типа. Вместо этого, инициализация shoppingList может быть записана в сокращенной форме:

```swift
var shoppingList = ["Eggs", "Milk"]
```

Поскольку все значения внутри литерала массива одинакового типа, Swift может вывести, что [String] является правильным типом для переменной shoppingList.

## Доступ и изменение массива
Вы можете получить доступ к массиву и изменять его либо через его методы и свойства, либо используя синтаксис сабскриптов.

Чтобы узнать количество элементов в массиве, проверьте его read-only свойство count:

```swift
print("The shopping list contains \(shoppingList.count) items.")
// Выведет "The shopping list contains 2 items."
```

Логическое свойство isEmpty можно использовать в качестве быстрого способа узнать, является ли свойство count равным 0:

```swift
if shoppingList.isEmpty {
    print("The shopping list is empty.")
} else {
    print("The shopping list is not empty.")
}
// Выведет "The shopping list is not empty."
```

Вы можете добавить новый элемент в конец массива через вызов метода append:

```swift
shoppingList.append("Flour")
​// shoppingList теперь содержит 3 элемента, а кое-кто делает блины
```

Кроме того, добавить массив с одним или несколькими совместимыми элементами можно с помощью оператора сложения и присвоения (+=):

```swift
shoppingList += ["Baking Powder"]
​// shoppingList теперь хранит 4 элемента
​shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
​// shoppingList теперь хранит 7 элементов
```

Можно извлечь значение из массива с помощью синтаксиса сабскриптов, поместив индекс значения, который вы хотите получить, внутри квадратных скобок сразу после имени массива.

```swift
var firstItem = shoppingList[0]
// firstItem равен "Eggs"
```

    Первый элемент в этом массиве имеет индекс 0, а не 1. Массивы в Swift всегда начинаются с 0.

Вы можете использовать синтаксис сабскриптов для изменения существующего значения данного индекса:

```swift
shoppingList[0] = "Six eggs"
​// первый элемент в списке теперь равен "Six eggs", а не "Eggs"
```

Вы также можете использовать синтаксис сабскриптов для изменения диапазона значений за раз, даже если набор изменяющих значений имеет разную длину, по сравнению с диапазоном который требуется заменить. Следующий пример заменяет "Chocolate Spread", "Cheese", и "Butter" на "Bananas" и "Apples":

```swift
shoppingList[4...6] = ["Bananas", "Apples"]
​// shoppingList теперь содежит 6 элементов
```

Для вставки элемента по заданному индексу внутрь массива, вызовите его метод insert(_:at:) :

```swift
shoppingList.insert("Maple Syrup", at: 0)
​// shoppingList теперь содержит 7 элементов
​// "Maple Syrup" теперь первый элемент списка
```

Вызвав этот insert(_:at:) метод, мы вставили новый элемент со значением "Maple Syrup" в самое начало списка покупок, то есть в элемент с индексом 0.

Аналогичным образом можно удалить элемент из массива с помощью метода remove(at:). Этот метод удаляет элемент с указанным индексом и возвращает удалённый элемент (хотя вы можете игнорировать возвращаемое значение если оно вам не нужно):

```swift
let mapleSyrup = shoppingList.remove(at: 0)
​// элемент который имел индекс 0 был удален
​// shoppingList теперь содержит 6 элементов, и нет Maple Syrup
​// константа mapleSyrup теперь равна удаленной строке "Maple Syrup"
```

    Если вы пытаетесь получить доступ или изменить значение индекса, который находится за пределами существующих границ массива, у вас будет ошибка исполнения. Вы можете проверить, действителен ли индекс, прежде чем его использовать, сравнив его с свойством count массива. За исключением случаев, когда count равен 0 (то есть массив пуст), самый большой валидный индекс в массиве всегда будет count - 1, так как массивы индексируются c нуля.

Любые пробелы внутри массива закрываются когда удаляется элемент, и поэтому значение с индексом 0 опять равно "Six eggs":

```swift
firstItem = shoppingList[0]
​// firstItem теперь равен "Six eggs"
```

Если вы хотите удалить последний элемент из массива, то можно использовать метод removeLast() вместо remove(at:), чтобы избежать необходимости запроса свойства count для массива. Также как и метод remove(at:), removeLast() возвращает удаленный элемент:

```swift
let​ ​apples​ = ​shoppingList​.​removeLast​()
// последний элемент массива был удален
// shoppingList теперь содержит 5 элементов, и нет яблок
// константа apples теперь равна удаленной строке "Apples"
```

## Итерация по массиву
Вы можете выполнить итерацию по всему набору значений внутри массива с помощью цикла for-in :

```swift
for item in shoppingList {
    print(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
```

Если вам нужен целочисленный индекс каждого значения так же как и самое значение, используйте вместо этого глобальную функцию enumerated() для итерации по массиву. Функция enumerated() возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента. Вы можете разложить кортеж во временные константы или переменные в рамках итерации:

```swift
for (index, value) in shoppingList.enumerated() {
    print("Item \(index + 1): \(value)")
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
```
